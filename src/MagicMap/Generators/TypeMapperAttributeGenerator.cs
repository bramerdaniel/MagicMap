// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeMapperAttributeCode.cs" company="consolovers">
//   Copyright (c) daniel bramer 2022 - 2023
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace MagicMap.Generators
{
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using MagicMap.Generators.TypeMapper;
   using Microsoft.CodeAnalysis;

   internal class TypeMapperAttributeGenerator
   {
      private readonly INamedTypeSymbol attributeSymbol;

      private readonly PropertyMappingAttributeGenerator propertyMappingAttribute;

      private readonly PropertyMapperAttributeGenerator propertyMapperAttribute;

      private readonly TypeFactoryInterfaceGenerator typeFactory;

      #region Public Properties

      public static string Code { get; } = @"//------------------------------------------------
// <auto-generated>
//     Generated by the MagicMap source generator
// </auto-generated>
//------------------------------------------------
namespace MagicMap 
{
   [global::System.Runtime.CompilerServices.CompilerGenerated]
   [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
   internal sealed class TypeMapperAttribute : global::System.Attribute
   {
      public TypeMapperAttribute(global::System.Type left, global::System.Type right)
      {
         Left = left ?? throw new global::System.ArgumentNullException(nameof(left));
         Right = right ?? throw new global::System.ArgumentNullException(nameof(right));
      }

      /// <summary>Gets the left type.</summary>
      public global::System.Type Left { get; }

      /// <summary>Gets the right type.</summary>
      public global::System.Type Right { get; }
   }
}
";

      #endregion

      internal static string TypeMapperAttributeName => "MagicMap.TypeMapperAttribute";

      internal static TypeMapperAttributeGenerator FromCompilation(Compilation compilation)
      {
         var attributeType = compilation.GetTypeByMetadataName(TypeMapperAttributeName);
         if (attributeType == null)
            throw new InvalidOperationException($"The source generator should have generated the type {TypeMapperAttributeName} before");

         var mappingAttribute = PropertyMappingAttributeGenerator.FromCompilation(compilation);
         var mapperAttribute = PropertyMapperAttributeGenerator.FromCompilation(compilation);
         var typeFactory = TypeFactoryInterfaceGenerator.FromCompilation(compilation);
         return new TypeMapperAttributeGenerator(attributeType, mappingAttribute, mapperAttribute, typeFactory) { Compilation = compilation };
      }

      protected Compilation Compilation { get; private set; }

      private TypeMapperAttributeGenerator(INamedTypeSymbol attributeSymbol, PropertyMappingAttributeGenerator propertyMappingAttribute,
         PropertyMapperAttributeGenerator propertyMapperAttribute, TypeFactoryInterfaceGenerator typeFactory)
      {
         this.attributeSymbol = attributeSymbol ?? throw new ArgumentNullException(nameof(attributeSymbol));
         this.propertyMappingAttribute = propertyMappingAttribute ?? throw new ArgumentNullException(nameof(propertyMappingAttribute));
         this.propertyMapperAttribute = propertyMapperAttribute ?? throw new ArgumentNullException(nameof(propertyMapperAttribute));
         this.typeFactory = typeFactory ?? throw new ArgumentNullException(nameof(typeFactory));
      }

      public bool TryExtractData(INamedTypeSymbol classSymbol, out ITypeMapperContext typeMapperContext)
      {
         var typeMapperAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(x => attributeSymbol.Equals(x.AttributeClass, SymbolEqualityComparer.Default));

         if (typeMapperAttribute == null || typeMapperAttribute.ConstructorArguments.Length != 2)
         {
            typeMapperContext = null;
            return false;
         }

         // TODO we could support partial nested classes
         if (IsNestedClass(classSymbol))
         {
            typeMapperContext = null;
            return false;
         }

         var value = typeMapperAttribute.ConstructorArguments[0].Value;
         var left = value as INamedTypeSymbol;

         value = typeMapperAttribute.ConstructorArguments[1].Value;
         var right = value as INamedTypeSymbol;

         var extensionsClassName = GetExtensionsClassName(classSymbol);
         var typeSymbol = Compilation.GetTypeByMetadataName(extensionsClassName);
         typeMapperContext = new TypeMapperContext
         {
            MapperType = classSymbol,
            MapperExtensionsType = typeSymbol,
            SourceType = left,
            TargetType = right,
            PropertyMappingAttribute = propertyMappingAttribute.AttributeClass,
            PropertyMapperAttribute = propertyMapperAttribute.AttributeClass,
            MappingSpecifications = CreateMappingDescriptions(classSymbol)
         };
         return true;
      }

      private static string GetExtensionsClassName(INamedTypeSymbol classSymbol)
      {
         if (classSymbol.ContainingNamespace.IsGlobalNamespace)
            return $"{classSymbol.Name}Extensions";

         var fullNamespace = classSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         fullNamespace = fullNamespace.Replace("global::", string.Empty);
         return $"{fullNamespace}.{classSymbol.Name}Extensions";
      }

      private static bool IsNestedClass(INamedTypeSymbol classSymbol)
      {
         if (classSymbol.ContainingType == null)
            return false;

         return classSymbol.ContainingType.IsType;
      }

      private IDictionary<string, MappingDescription> CreateMappingDescriptions(INamedTypeSymbol classSymbol)
      {
         var mappings = new Dictionary<string, MappingDescription>();
         foreach (var (leftName, rightName) in propertyMappingAttribute.ComputePropertyMappings(classSymbol))
            mappings[leftName] = rightName;

         return mappings;
      }
   }

   internal struct MappingDescription
   {
      public string Name { get; set; }

      public bool Ignored { get; set; }
   }
}