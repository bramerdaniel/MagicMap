// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeMapperAttributeCode.cs" company="consolovers">
//   Copyright (c) daniel bramer 2022 - 2023
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace MagicMap.Generators
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using MagicMap.Generators.TypeMapper;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp.Syntax;

    internal class TypeMapperAttributeGenerator
    {
        private readonly INamedTypeSymbol attributeSymbol;

        private readonly PropertyMappingAttributeGenerator propertyMappingAttribute;

        #region Public Properties

        public static string Code { get; } = @"//------------------------------------------------
// <auto-generated>
//     Generated by the MagicMap source generator
// </auto-generated>
//------------------------------------------------
namespace MagicMap 
{
   [global::System.Runtime.CompilerServices.CompilerGenerated]
   [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
   internal sealed class TypeMapperAttribute : global::System.Attribute
   {
      public TypeMapperAttribute(global::System.Type left, global::System.Type right)
      {
         Left = left ?? throw new global::System.ArgumentNullException(nameof(left));
         Right = right ?? throw new global::System.ArgumentNullException(nameof(right));
      }

      /// <summary>Gets the left type.</summary>
      public global::System.Type Left { get; }

      /// <summary>Gets the right type.</summary>
      public global::System.Type Right { get; }
   }
}
";

        #endregion

        internal static string TypeMapperAttributeName => "MagicMap.TypeMapperAttribute";

        internal static TypeMapperAttributeGenerator FromCompilation(Compilation compilation)
        {
            var attributeType = compilation.GetTypeByMetadataName(TypeMapperAttributeName);
            if (attributeType == null)
                throw new InvalidOperationException($"The source generator should have generated the type {TypeMapperAttributeName} before");

            var mappingAttribute = PropertyMappingAttributeGenerator.FromCompilation(compilation);
            return new TypeMapperAttributeGenerator(attributeType, mappingAttribute);
        }

        private TypeMapperAttributeGenerator(INamedTypeSymbol attributeSymbol, PropertyMappingAttributeGenerator propertyMappingAttribute)
        {
            this.attributeSymbol = attributeSymbol ?? throw new ArgumentNullException(nameof(attributeSymbol));
            this.propertyMappingAttribute = propertyMappingAttribute ?? throw new ArgumentNullException(nameof(propertyMappingAttribute));
        }

        public bool TryExtractData(INamedTypeSymbol classSymbol, out ITypeMapperContext typeMapperContext)
        {
            var typeMapperAttribute = classSymbol.GetAttributes()
               .FirstOrDefault(x => attributeSymbol.Equals(x.AttributeClass, SymbolEqualityComparer.Default));

            if (typeMapperAttribute == null || typeMapperAttribute.ConstructorArguments.Length != 2)
            {
                typeMapperContext = null;
                return false;
            }

            var value = typeMapperAttribute.ConstructorArguments[0].Value;
            var left = value as INamedTypeSymbol;

            value = typeMapperAttribute.ConstructorArguments[1].Value;
            var right = value as INamedTypeSymbol;

            typeMapperContext = new TypeMapperContext
            {
                MapperType = classSymbol,
                SourceType = left,
                TargetType = right,
                MappingSpecifications = CreateMappingDescriptions(classSymbol)
            };
            return true;
        }

        private IDictionary<string, string> CreateMappingDescriptions(INamedTypeSymbol classSymbol)
        {
            var mappings = new Dictionary<string, string>();
            foreach (var (leftName, rightName) in propertyMappingAttribute.ComputePropertyMappings(classSymbol))
                mappings[leftName] = rightName;

            return mappings;
        }
    }
}