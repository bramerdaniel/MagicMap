// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeMapperAttributeCode.cs" company="consolovers">
//   Copyright (c) daniel bramer 2022 - 2023
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace MagicMap.Generators
{
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using MagicMap.Generators.TypeMapper;
   using Microsoft.CodeAnalysis;
   using Microsoft.CodeAnalysis.CSharp.Syntax;

   internal class TypeMapperAttributeGenerator
   {
      private readonly INamedTypeSymbol attributeSymbol;

      private readonly PropertyMappingAttributeGenerator propertyMappingAttribute;

      #region Public Properties

      public static string Code { get; } = @"//------------------------------------------------
// <auto-generated>
//     Generated by the MagicMap source generator
// </auto-generated>
//------------------------------------------------
namespace MagicMap 
{
   [global::System.Runtime.CompilerServices.CompilerGenerated]
   [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
   internal sealed class TypeMapperAttribute : global::System.Attribute
   {
      public TypeMapperAttribute(global::System.Type left, global::System.Type right)
      {
         Left = left ?? throw new global::System.ArgumentNullException(nameof(left));
         Right = right ?? throw new global::System.ArgumentNullException(nameof(right));
      }

      /// <summary>Gets the left type.</summary>
      public global::System.Type Left { get; }

      /// <summary>Gets the right type.</summary>
      public global::System.Type Right { get; }
   }
}
";

      #endregion

      internal static string TypeMapperAttributeName => "MagicMap.TypeMapperAttribute";

      internal static TypeMapperAttributeGenerator FromCompilation(Compilation compilation)
      {
         var attributeType = compilation.GetTypeByMetadataName(TypeMapperAttributeName);
         if (attributeType == null)
            throw new InvalidOperationException($"The source generator should have generated the type {TypeMapperAttributeName} before");

         var mappingAttribute = PropertyMappingAttributeGenerator.FromCompilation(compilation);
         return new TypeMapperAttributeGenerator(attributeType, mappingAttribute);
      }

      private TypeMapperAttributeGenerator(INamedTypeSymbol attributeSymbol, PropertyMappingAttributeGenerator propertyMappingAttribute)
      {
         this.attributeSymbol = attributeSymbol ?? throw new ArgumentNullException(nameof(attributeSymbol));
         this.propertyMappingAttribute = propertyMappingAttribute ?? throw new ArgumentNullException(nameof(propertyMappingAttribute));
      }

      private static bool IsGeneratedPartialPart(INamedTypeSymbol namedTypeSymbol)
      {
         

         foreach (var reference in namedTypeSymbol.DeclaringSyntaxReferences)
         {
            if (reference.SyntaxTree.FilePath.EndsWith(".generated.cs", StringComparison.InvariantCultureIgnoreCase))
               return true;
         }

         return false;
      }

      public bool TryExtractData(INamedTypeSymbol classSymbol, out ITypeMapperContext typeMapperContext)
      {
         var typeMapperAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(x => attributeSymbol.Equals(x.AttributeClass, SymbolEqualityComparer.Default));

         if (typeMapperAttribute == null || typeMapperAttribute.ConstructorArguments.Length != 2)
         {
            typeMapperContext = null;
            return false;
         }

         if (IsNestedClass(classSymbol))
         {
            typeMapperContext = null;
            return false;
         }

         var value = typeMapperAttribute.ConstructorArguments[0].Value;
         var left = value as INamedTypeSymbol;

         value = typeMapperAttribute.ConstructorArguments[1].Value;
         var right = value as INamedTypeSymbol;

         typeMapperContext = new TypeMapperContext
         {
            MapperType = classSymbol,
            SourceType = left,
            TargetType = right,
            MappingSpecifications = CreateMappingDescriptions(classSymbol)
         };
         return true;
      }

      private static bool IsNestedClass(INamedTypeSymbol classSymbol)
      {
         if (classSymbol.ContainingType == null)
            return false;
         
         return classSymbol.ContainingType.IsType;
      }

      private IDictionary<string, string> CreateMappingDescriptions(INamedTypeSymbol classSymbol)
      {
         var mappings = new Dictionary<string, string>();
         foreach (var (leftName, rightName) in propertyMappingAttribute.ComputePropertyMappings(classSymbol))
            mappings[leftName] = rightName;

         return mappings;
      }
   }
}