// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeMapperAttributeGenerator.cs" company="consolovers">
//   Copyright (c) daniel bramer 2022 - 2023
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace MagicMap.Generators
{
   using System;
   using System.Collections.Generic;
   using System.Linq;

   using MagicMap.Extensions;
   using MagicMap.Generators.TypeMapper;

   using Microsoft.CodeAnalysis;

   internal class TypeMapperAttributeGenerator
   {
      #region Constants and Fields

      private readonly INamedTypeSymbol attributeSymbol;

      private readonly PropertyMapperAttributeGenerator propertyMapperAttribute;

      private readonly PropertyMappingAttributeGenerator propertyMappingAttribute;

      private readonly TypeFactoryInterfaceGenerator typeFactory;

      #endregion

      #region Constructors and Destructors

      private TypeMapperAttributeGenerator(INamedTypeSymbol attributeSymbol, PropertyMappingAttributeGenerator propertyMappingAttribute,
         PropertyMapperAttributeGenerator propertyMapperAttribute, TypeFactoryInterfaceGenerator typeFactory)
      {
         this.attributeSymbol = attributeSymbol ?? throw new ArgumentNullException(nameof(attributeSymbol));
         this.propertyMappingAttribute = propertyMappingAttribute ?? throw new ArgumentNullException(nameof(propertyMappingAttribute));
         this.propertyMapperAttribute = propertyMapperAttribute ?? throw new ArgumentNullException(nameof(propertyMapperAttribute));
         this.typeFactory = typeFactory ?? throw new ArgumentNullException(nameof(typeFactory));
      }

      #endregion

      #region Public Properties

      public static string Code { get; } = @"//------------------------------------------------
// <auto-generated>
//     Generated by the MagicMap source generator
// </auto-generated>
//------------------------------------------------
namespace MagicMap 
{
   [global::System.Runtime.CompilerServices.CompilerGenerated]
   [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute]
   [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
   internal sealed class TypeMapperAttribute : global::System.Attribute
   {
      public TypeMapperAttribute(global::System.Type left, global::System.Type right)
      {
         Left = left ?? throw new global::System.ArgumentNullException(nameof(left));
         Right = right ?? throw new global::System.ArgumentNullException(nameof(right));
      }

      /// <summary>Gets the left type.</summary>
      public global::System.Type Left { get; }

      /// <summary>Gets the right type.</summary>
      public global::System.Type Right { get; }

      /// <summary>Gets or sets the <see cref=""GenerationMode""/>.</summary>
      public GeneratorMode Mode { get; set; } = GeneratorMode.TwoWay;

      /// <summary>Gets or sets a flag, indicating if the source generator should generate partial methods
      /// for properties he can not map, to enforce that they are handled by the user.</summary>
      public bool ForceMappings { get; set; } = false;
   }

   /// <summary>Enum for configuring the source generator mode</summary>
   internal enum GeneratorMode
   {
      /// <summary>Mappers are generated for both ways, from left to right and back</summary>
      TwoWay,

      /// <summary>Only a mapper from left to right typ is generated</summary>
      LeftToRight,

      /// <summary>Only a mapper from right to left typ is generated</summary>
      RightToLeft
   }
}
";

      #endregion

      #region Properties

      internal static string TypeMapperAttributeName => "MagicMap.TypeMapperAttribute";

      protected Compilation Compilation { get; private set; }

      #endregion

      #region Public Methods and Operators

      public bool TryExtractData(INamedTypeSymbol classSymbol, out ITypeMapperContext typeMapperContext)
      {
         var typeMapperAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(x => attributeSymbol.Equals(x.AttributeClass, SymbolEqualityComparer.Default));

         if (typeMapperAttribute == null || typeMapperAttribute.ConstructorArguments.Length != 2)
         {
            typeMapperContext = null;
            return false;
         }

         // TODO we could support partial nested classes
         if (IsNestedClass(classSymbol))
         {
            typeMapperContext = null;
            return false;
         }

         var value = typeMapperAttribute.ConstructorArguments[0].Value;
         var left = value as INamedTypeSymbol;

         value = typeMapperAttribute.ConstructorArguments[1].Value;
         var right = value as INamedTypeSymbol;

         var extensionsClassName = GetExtensionsClassName(classSymbol);
         var typeSymbol = Compilation.GetTypeByMetadataName(extensionsClassName);
         typeMapperContext = new TypeMapperContext(classSymbol)
         {
            MapperExtensionsType = typeSymbol,
            SourceType = left,
            TargetType = right,
            Mode = ParseMode(typeMapperAttribute),
            ForceMappings = typeMapperAttribute.GetNamedArgument("ForceMappings", () => false),
            PropertyMappingAttribute = propertyMappingAttribute.AttributeClass,
            PropertyMapperAttribute = propertyMapperAttribute.AttributeClass,
            MappingSpecifications = CreateMappingDescriptions(classSymbol)
         };
         return true;
      }

      #endregion

      #region Methods

      internal static TypeMapperAttributeGenerator FromCompilation(Compilation compilation)
      {
         var attributeType = compilation.GetTypeByMetadataName(TypeMapperAttributeName);
         if (attributeType == null)
            throw new InvalidOperationException($"The source generator should have generated the type {TypeMapperAttributeName} before");

         var mappingAttribute = PropertyMappingAttributeGenerator.FromCompilation(compilation);
         var mapperAttribute = PropertyMapperAttributeGenerator.FromCompilation(compilation);
         var typeFactory = TypeFactoryInterfaceGenerator.FromCompilation(compilation);
         return new TypeMapperAttributeGenerator(attributeType, mappingAttribute, mapperAttribute, typeFactory) { Compilation = compilation };
      }

      private static string GetExtensionsClassName(INamedTypeSymbol classSymbol)
      {
         if (classSymbol.ContainingNamespace.IsGlobalNamespace)
            return $"{classSymbol.Name}Extensions";

         var fullNamespace = classSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
         fullNamespace = fullNamespace.Replace("global::", string.Empty);
         return $"{fullNamespace}.{classSymbol.Name}Extensions";
      }

      private static bool IsNestedClass(INamedTypeSymbol classSymbol)
      {
         if (classSymbol.ContainingType == null)
            return false;

         return classSymbol.ContainingType.IsType;
      }

      private IDictionary<string, MappingDescription> CreateMappingDescriptions(INamedTypeSymbol classSymbol)
      {
         var mappings = new Dictionary<string, MappingDescription>();
         foreach (var (leftName, rightName) in propertyMappingAttribute.ComputePropertyMappings(classSymbol))
            mappings[leftName] = rightName;

         return mappings;
      }

      private GeneratorMode ParseMode(AttributeData attributeData)
      {
         if (attributeData.TryGetNamedArgument("Mode", out var typeConstant))
         {
            var value = typeConstant.Value?.ToString();
            if (value != null)
               return (GeneratorMode)Enum.Parse(typeof(GeneratorMode), value);
         }

         return GeneratorMode.TwoWay;
      }

      #endregion
   }
}