// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeMapperGenerator.cs" company="consolovers">
//   Copyright (c) daniel bramer 2022 - 2023
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace MagicMap.Generators;

using System;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

internal class TypeMapperGenerator : IMagicGenerator
{
   private readonly ITypeMapperContext context;

   public TypeMapperGenerator(ITypeMapperContext context)
   {
      this.context = context ?? throw new ArgumentNullException(nameof(context));

   }

   public GeneratedSource Generate()
   {
      var builder = new StringBuilder();
      builder.AppendLine("// <auto-generated>");

      if (!context.MapperType.ContainingNamespace.IsGlobalNamespace)
      {
         builder.AppendLine($"namespace {context.MapperType.ContainingNamespace.ToDisplayString()}");
         builder.AppendLine("{");
      }

      GenerateMapperClass(builder);

      if (!context.MapperType.ContainingNamespace.IsGlobalNamespace)
         builder.AppendLine("}");

      var generatedSource = new GeneratedSource
      {
         Name = context.MapperType.Name + ".generated.cs",
         Code = builder.ToString()
      };

      return generatedSource;
   }

   private void GenerateMapperClass(StringBuilder builder)
   {
      builder.AppendLine($"partial class {context.MapperType.Name}");
      builder.AppendLine("{");
      GenerateMappingMethod(builder);
      builder.AppendLine("}");
   }

   private void GenerateMappingMethod(StringBuilder builder)
   {
      var targetProperties = context.TargetType.GetMembers()
         .OfType<IPropertySymbol>()
         .ToDictionary(p => p.Name, StringComparer.InvariantCultureIgnoreCase);



      AppendMapperSignature(builder);
      builder.AppendLine("{");

      if (targetProperties.Count == 0)
      {
         builder.AppendLine("// target type does not contain any properties.");
         builder.AppendLine("// No mappings were generated");
      }
      else
      {
         foreach (var source in context.SourceType.GetMembers().OfType<IPropertySymbol>())
         {
            if (targetProperties.TryGetValue(source.Name, out var target))
            {
               if (!target.Type.Equals(source.Type, SymbolEqualityComparer.Default))
               {

                  builder.AppendLine("// types do not match");
                  builder.Append($"Map{source.Name}(target, source.{source.Name});");
               }
               else
               {
                  builder.AppendLine($"target.{source.Name} = source.{target.Name}");
               }
            }
         }
      }

      builder.AppendLine("}");
   }

   private void AppendMapperSignature(StringBuilder builder)
   {
      builder.Append("public void Map(");
      builder.Append(context.SourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
      builder.Append(" source");
      builder.Append(", ");
      builder.Append(context.TargetType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
      builder.Append(" target");
      builder.AppendLine(")");
   }
}