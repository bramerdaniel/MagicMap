// --------------------------------------------------------------------------------------------------------------------
// <copyright file="TypeMapperAttributeCode.cs" company="consolovers">
//   Copyright (c) daniel bramer 2022 - 2023
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

namespace MagicMap
{
   using System;
   using System.Linq;

   using Microsoft.CodeAnalysis;
   using Microsoft.CodeAnalysis.CSharp.Syntax;

   internal class TypeMapperAttributeCode
   {
      private readonly INamedTypeSymbol attributeSymbol;

      #region Public Properties

      public static string Code { get; set; } = @"// <auto-generated>
namespace MagicMap 
{
   [global::System.Runtime.CompilerServices.CompilerGenerated]
   [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
   internal sealed class TypeMapperAttribute : global::System.Attribute
   {
      public TypeMapperAttribute(global::System.Type left, global::System.Type right)
      {
         Left = left ?? throw new global::System.ArgumentNullException(nameof(left));
         Right = right ?? throw new global::System.ArgumentNullException(nameof(right));
      }

      /// <summary>Gets the left type.</summary>
      public global::System.Type Left { get; }

      /// <summary>Gets the right type.</summary>
      public global::System.Type Right { get; }
   }
}
";

      #endregion

      internal static string TypeMapperAttributeName => "MagicMap.TypeMapperAttribute";

      internal static TypeMapperAttributeCode FromCompilation(Compilation compilation)
      {
         var attributeType = compilation.GetTypeByMetadataName(TypeMapperAttributeName);
         if (attributeType == null)
            throw new InvalidOperationException($"The source generator should have generated the type {TypeMapperAttributeName} before");
         return new TypeMapperAttributeCode(attributeType);
      }

      private TypeMapperAttributeCode(INamedTypeSymbol attributeSymbol)
      {
         this.attributeSymbol = attributeSymbol ?? throw new ArgumentNullException(nameof(attributeSymbol));
      }

      public bool TryExtractData(INamedTypeSymbol classSymbol, out ITypeMapperContext typeMapperContext)
      {
         var typeMapperAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(x => attributeSymbol.Equals(x.AttributeClass, SymbolEqualityComparer.Default));

         if (typeMapperAttribute == null || typeMapperAttribute.ConstructorArguments.Length != 2)
         {
            typeMapperContext = null;
            return false;
         }
         
         var value = typeMapperAttribute.ConstructorArguments[0].Value;
         var left = value as INamedTypeSymbol;

         value = typeMapperAttribute.ConstructorArguments[1].Value;
         var right = value as INamedTypeSymbol;

         typeMapperContext = new TypeMapperContext { MapperType = classSymbol, LeftType = left, RightType = right };
         return true;
      }
   }
}